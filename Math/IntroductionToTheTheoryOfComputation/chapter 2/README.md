# Context-Free Languages

In this chapter, we present *context-free grammars*, a more powerful
method of describing languages. Such grammars can describe certain
features that have a recursive structure, which makes them useful
in a variety of applications.

The collection of languages associated with context-free grammars are
called *context-free languages*. They include all the regular languages and many additional languages.

## 2.1 Context-Free Grammars

The following is an example of a context-free grammar, which we call $G_{1}$.

$$
\begin{align*}
A &\to 0A1 \\
A &\to B   \\
B &\to \#
\end{align*}
$$

A grammar consists of a collection of *substitution rules*, also called *productions*.
Each rule appears as a line in the grammar, comprising a symbol and
a string separated by an arrow. The symbol is called a *variable*. The string
consists of variables and other symbols are called *terminals*.

The variable symbols often are represented by capital letters. The terminals
are analogous to the input alphabet and often are represented by
lowercase letters, numbers, or special symbols. One variable is designated as
the *start variable*. It usually occurs on the left-hand side
of the topmost rule. For example, grammar $G_{1}$ contains three rules.
$G_{1}$'s variables are $A$ and $B$, where $A$ is the start variable.
Its terminals are $0$, $1$ and $\#$.

You use a grammar to describe a language by generating each string
of that language in the following manner.

1. Write down the start variable. It is the variable on the left-hand
side of the top rule, unless specified otherwise.
2. Find a variable that is written down and a rule that starts with that variable.
Replace the written down variable with the right-hand side of that rule.
3. Repeat step 2 until no variables remain.

For example, grammar $G_{1}$ generates the string `000#111`. The sequence of
substitutions to obtain a string is called a *derivation*.
A derivation of string `000#111` in grammar $G_{1}$ is

$$
A \Rightarrow 0A1 \Rightarrow 00A11
\Rightarrow 000A111 \Rightarrow 000B111
\Rightarrow 000\#111
$$

You may also represent the same information pictorially with a *parse tree*.

<!-- TODO: add the picture -->
![Parse tree for 000#111](.)

All strings generated in this way constitute the *language of the grammar*.
We write $L(G_{1})$ for the language of grammar $G_{1}$.
Any language that can be generated by some context-free grammar is
called a *context-free language*(CFL). For convenience when presenting
a context-free grammar, we abbreviate several rules with the same
left-hand variable, such as $A \to 0A1$ and $A \to B$,
into a single line
$A \to 0A1|B$.

### 2.1.1 Formal Definition of a Context-Free Grammar

A *context-free grammar* is a 4-tuple $(V, \Sigma, R, S)$

+ $V$ is a finite set called the *variables*.
+ $\Sigma$ is a finite set, disjoint from $V$, called the terminals.
+ $R$ is a finite set of *rules*, with each rule being a variable and a string
of variables and terminals.
+ $S \in V$ is the start variable.

### 2.1.2 Designing Context-Free Grammars

The design of context-free grammars requires creativity. Indeed, context-free
grammars are even trickier to construct than finite automata because
we are more accustomed to programming a machine for specific tasks than we
are to describing languages with grammars.

First, many CFLs are the union of simpler CFLs. If you must construct a
CFG for a CFL that you can break into simpler pieces, do so and then
construct individual grammars for each piece. These individual grammars can
be easily merged into a grammar for the original language by combining their
rules and the adding the new rule $S \to S_{1} | S_{2} \cdots S_{k}$,
where the variables $S_{i}$ are the start variables for the individual grammars.

For example, to get a grammar for the language
$\{0^{n}1^{n} | n \geq 0 \}\cup \{1^{n}0^{n} | n \geq 0\}$,

$$
\begin{align*}
S &\to S_{1} | S_{2} \\
S_{1} &\to 0S_{1}1 | \epsilon \\
S_{2} &\to 0S_{2}0 | \epsilon
\end{align*}
$$

Second, constructing a CFG for a language that happens to be
regular is easy if you can first construct a DFA for that language. You
can convert any DFA into an equivalent CFG as follows. Make a variable
$R_{i}$ for each state $q_{i}$ of the DFA. Add the rule $R_{i} \to aR_{j}$
to the CFG if $\delta_{q_{i}, a} = q_{j}$ is a transition in the DFA. Add
the rule $R_{i} \to \epsilon$ if $q_{i}$ is an accept state of the DFA. Make
$R_{0}$ the start variable of the grammar, where $q_{0}$ is the start state of
the machine.

Third, certain context-free languages contain strings with two
substrings that are "linked" in the sense that a machine for such a language
would need to remember an unbounded amount of information about one of
the substrings to verify that it corresponds properly to the
other substring. You can construct a CFG to handle this situation
by using a rule of the form $R \to uRv$, which generates a strings wherein
the portion containing the $u$ corresponds to the portion
contains the $v$.

### 2.1.3 Ambiguity

Sometimes a grammar can generate the same string in several different
ways. Such a string will have several different parse trees
and thus several different meanings. This result may be undesirable
for certain applications, such as programming languages, where
a program should have a unique interpretation.

If a grammar generates the same string in several different ways,
we say that the string is derived *ambiguously* in that grammar. If a grammar generates some string
ambiguously, we say that the grammar is *ambiguous*.

### 2.1.4 Chomsky Normal Form

When working with context-free grammars, it is often convenient to
have them in simplified form. One of the simplest and most useful
forms is called the Chomsky normal form.

A context-free grammar is in *Chomsky normal form* if every rule
is of the form

$$
\begin{align*}
A &\to BC \\
A \to a
\end{align*}
$$

$a$ is any terminal and $A$, $B$, AND $C$ are any variables. In addition,
we permit the rule $S \to \epsilon$, where $S$ is the start variable.

#### Theorem 1

Any context-free language is generated by a context-free grammar
in Chomsky normal form.

#### Proof 1

First, we add a new start variable $S_{0}$ and the rule $S_{0} \to S$,
where $S$ was the original start variable. This change guarantees that
the start variable doesn't occur on the right-hand side of a rule.

Second, we take care of all $\epsilon$-rules. We remove an
$\epsilon$-rule $A \to \epsilon$, where $A$ is not the start variable.
Then for each occurrence of an $A$ on the right-hand side of a rule, we
add a new rule with that occurrence deleted. In other words,
if $R \to uAv$ is a rule in which $u$ and $v$ are strings of
variables and terminals, we add rule $R \to uv$. We do so for each occurrence
of an $A$, so the rule $R \to uAvAw$ causes us to add $R \to uvAw$,
$R \to uAvw$, and $R \to uvw$.

Third, we handle all unit rules. We remove a unit rule $A \to B$.
Then whenever a rule $B \to u$ appears, we add the rule $A \to u$ unless
this was a unit previously removed. As before, $u$ is a string
of variables and terminals. We repeat these steps until we eliminate
all unit rules.

Finally, we convert all remaining rules into the proper form.
We replace each rule $A \to u_{1}u_{2}\cdots u_{k}$, where $k \geq 3$
and each $u_{i}$ is a variable or terminal symbol, with
the rules $A \to u_{1}A_{1}, A_{1} \to u_{2}A_{2}, \dots,$ and
$A_{k - 2} \to u_{k-1}u_{k}$. The $A_{i}$s are new variables.
We replace any terminal $u_{i}$ in the preceding rules with
the new variable $U_{i}$ and add the rule $U_{i} \to u_{i}$.

## 2.2 Pushdown Automata

In this section we introduce new type of computational model called
*pushdown automata*. These automata are like nondeterministic finite automate
but have an extra component called a *stack*. The stack provides additional memory
beyond the finite amount variable in the control. The stack allows pushdown
automate to recognize some nonregular languages.

A pushdown automaton(PDA) can write symbols on the stack and read
them back later. Writing a symbol "pushes down" all the other symbols
on the stack. At any time the symbol on the top of the stack can be read
and removed. The remaining symbols then move back up.

A stack is valuable because it can hold an unlimited amount of information.
For language $\{0^{n}1^{n} | n \geq 0\}$, a PDA can read symbols
from the input. As each 0 is read, push it onto the stack. As soon
as 1 are seen, pop a 0 off the stack for each 1 read. If reading
the input is finished exactly when the stack becomes empty
of 0, accept the input.

### 2.2.1 Formal Definition of A Pushdown Automaton

A *pushdown automaton* is a 6-tuple $(Q,\Sigma, \Gamma, \delta, q_{0}, F)$,
where $Q,\Sigma, \Gamma$ and $F$ are all finite sets, and

1. $Q$ is the set of states.
2. $\Sigma$ is the input alphabet.
3. $\Gamma$ is the stack alphabet.
4. $\delta$: $Q \times \Sigma_{\epsilon} \times \Gamma_{\epsilon} \to \mathcal{P}(Q \times \Gamma_{\epsilon})$
is the transition function.
5. $q_{0} \in Q$ is the start state.
6. $F \subseteq Q$ is the set of accept states.

A pushdown automaton $M = (Q,\Sigma, \Gamma, \delta, q_{0}, F)$ computes
as follows. It accepts input $w$ if $w$ can be written as
$w = w_{1}w_{2}\dots w_{m}$, where each $w_{i} in \Sigma_{\epsilon}$ and
sequences of stats $r_{0},r_{1}, \dots, r_{m} \in Q$ and strings
$s_{0}, s_{1}, \dots, s_{m} \in \Gamma^{*}$ exists that satisfy the following
three conditions. The strings $s_{i}$ represent the sequence
of stack contents that $M$ has on accepting branch of
the computation.

1. $r_{0} = q_{0}$ and $s_{0} = \epsilon$. This condition signifies that $M$
starts our properly, in the start state and with an empty stack.
2. For $i = 0, \dots, m - 1$, we have $(r_{i + 1}, b) \in \delta(r_{i}, w_{i + 1}, a)$
where $s_{i} = at$ and $s_{i + 1} = bt$ for some $a, b \in \Gamma_{\epsilon}$
and $t \in \Gamma_{*}$. This condition states that $M$ moves
properly according to the state, stack, and the next input symbol.
3.$r_{m} \in F$. This condition states that an accept state occurs at the input end

#### Theorem 2

A language is context free if and only if some pushdown
automaton recognizes it.

And we can get if a language is context free, then some
pushdown automaton recognizes it.
