# Context-Free Languages

In this chapter, we present *context-free grammars*, a more powerful
method of describing languages. Such grammars can describe certain
features that have a recursive structure, which makes them useful
in a variety of applications.

The collection of languages associated with context-free grammars are
called *context-free languages*. They include all the regular languages and many additional languages.

## 2.1 Context-Free Grammars

The following is an example of a context-free grammar, which we call $G_{1}$.

$$
\begin{align*}
A &\to 0A1 \\
A &\to B   \\
B &\to \#
\end{align*}
$$

A grammar consists of a collection of *substitution rules*, also called *productions*.
Each rule appears as a line in the grammar, comprising a symbol and
a string separated by an arrow. The symbol is called a *variable*. The string
consists of variables and other symbols are called *terminals*.

The variable symbols often are represented by capital letters. The terminals
are analogous to the input alphabet and often are represented by
lowercase letters, numbers, or special symbols. One variable is designated as
the *start variable*. It usually occurs on the left-hand side
of the topmost rule. For example, grammar $G_{1}$ contains three rules.
$G_{1}$'s variables are $A$ and $B$, where $A$ is the start variable.
Its terminals are $0$, $1$ and $\#$.

You use a grammar to describe a language by generating each string
of that language in the following manner.

1. Write down the start variable. It is the variable on the left-hand
side of the top rule, unless specified otherwise.
2. Find a variable that is written down and a rule that starts with that variable.
Replace the written down variable with the right-hand side of that rule.
3. Repeat step 2 until no variables remain.

For example, grammar $G_{1}$ generates the string `000#111`. The sequence of
substitutions to obtain a string is called a *derivation*.
A derivation of string `000#111` in grammar $G_{1}$ is

$$
A \Rightarrow 0A1 \Rightarrow 00A11
\Rightarrow 000A111 \Rightarrow 000B111
\Rightarrow 000\#111
$$

You may also represent the same information pictorially with a *parse tree*.

<!-- TODO: add the picture -->
![Parse tree for 000#111](.)

All strings generated in this way constitute the *language of the grammar*.
We write $L(G_{1})$ for the language of grammar $G_{1}$.
Any language that can be generated by some context-free grammar is
called a *context-free language*(CFL). For convenience when presenting
a context-free grammar, we abbreviate several rules with the same
left-hand variable, such as $A \to 0A1$ and $A \to B$,
into a single line
$A \to 0A1|B$.

### 2.1.1 Formal Definition of a Context-Free Grammar

A *context-free grammar* is a 4-tuple $(V, \Sigma, R, S)$

+ $V$ is a finite set called the *variables*.
+ $\Sigma$ is a finite set, disjoint from $V$, called the terminals.
+ $R$ is a finite set of *rules*, with each rule being a variable and a string
of variables and terminals.
+ $S \in V$ is the start variable.

### 2.1.2 Designing Context-Free Grammars

The design of context-free grammars requires creativity. Indeed, context-free
grammars are even trickier to construct than finite automata because
we are more accustomed to programming a machine for specific tasks than we
are to describing languages with grammars.

First, many CFLs are the union of simpler CFLs. If you must construct a
CFG for a CFL that you can break into simpler pieces, do so and then
construct individual grammars for each piece. These individual grammars can
be easily merged into a grammar for the original language by combining their
rules and the adding the new rule $S \to S_{1} | S_{2} \cdots S_{k}$,
where the variables $S_{i}$ are the start variables for the individual grammars.

For example, to get a grammar for the language
$\{0^{n}1^{n} | n \geq 0 \}\cup \{1^{n}0^{n} | n \geq 0\}$,

$$
\begin{align*}
S &\to S_{1} | S_{2} \\
S_{1} &\to 0S_{1}1 | \epsilon \\
S_{2} &\to 0S_{2}0 | \epsilon
\end{align*}
$$

## 2.2 Pushdown Automata

In this section we introduce new type of computational model called
*pushdown automata*. These automata are like nondeterministic finite automate
but have an extra component called a *stack*. The stack provides additional memory
beyond the finite amount variable in the control. The stack allows pushdown
automate to recognize some nonregular languages.
