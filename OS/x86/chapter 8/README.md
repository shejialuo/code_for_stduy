# Chapter 8 硬盘和显卡的访问与控制

## 用户程序的结构

### 分段、段的汇编地址和段内汇编地址

处理器的工作模式是将内存分成逻辑上的段，一个规范的程序，应当包括代码段、数据段、附加段和栈段。

NSAM编译器使用汇编指令`SECTION`或`SEGMENT`定义段。Intel处理器要求段在内存中的起始物理地址起码是16字节对齐的。相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用`align=`。

段的汇编地址其实就是段内第一个元素的汇编地址。为了方便取得段的汇编地址，NASM编译器提供了一下的表达式：

```asm
section.segment.start
```

尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头出计算的。故段定义语句还可以包含`vstart=`子句。

### 用户程序头部

用户程序头部需要包含以下的信息：

+ 用户程序的尺寸，即以字节为单位的大小。
+ 应用程序的入口点，包括段地址和偏移地址。

## 加载程序的工作流程

### 初始化和决定加载位置

加载器要加载一个用户程序，并使之开始执行，需要决定两件事：

+ 从哪个物理内存地址开始加载用户程序。
+ 用户程序位于硬盘的位置。

### 外围设备和接口

+ 总线机制。
+ 输入输出控制设备集中器。

### I/O端口和端口访问

处理器是通过端口来和外围设备打交道的。本质上，端口就是一些寄存器。Intel处理器早期是独立编址的，现在既有内存映射的，也有独立编址的。

在Intel的系统中只允许65536个端口存在，由于是独立编址，端口的访问不能使用类似于`mov`的指令，取而代之的是`in`和`out`指令。

```asm
in al, dx
in ax, dx
out 0x37, al
out 0xf5, ax
```

### 通过硬盘控制器端口读扇区数据

从硬盘读写数据，最经典的方式是向硬盘控制器分别发送磁头号、柱面号和扇区号，这称为CHS模式。实际上，在很多时候，我们并不关心扇区的物理位置，而是逻辑位置。个人计算机上的主硬盘控制器被分配了8位端口，端口号从`0x1f0`到`0x1f7`。

要从硬盘上读逻辑扇区，整个过程如下：

第一步，设置要读取的扇区数量。这个数量要写入`0x1f2`端口。

```asm
mov dx, 0x1f2
mov al, 0x01
out dx, al
```

第二步，设置起始扇区号。28位的扇区号需要分成4段，`0x1f3,0x1f4,0x1f5,0x1f6`。假定我们要读写的起始逻辑扇区号为`0x02`：

```asm
mov dx, 0x1f3
mov al, 0x02
out dx, al
inc dx
mov al, 0x00
out dx, al
inc dx
mov dx, al
inc dx
mov al, 0xe0
out dx, al
```

注意以上代码的最后4行，在现行的体系下，每个`PATA/SATA`接口允许挂起两个硬盘，分别是主盘和从盘。`0xf16`端口的低4位用于存放逻辑扇区号的24~27位，第4位用于指示硬盘号，0表示主盘，1表示从盘。高3位是111,表示LBA模式。

第三步，向端口`0x1f7`写入`0x20`，请求硬盘读。

```asm
mov dx, 0x1f7
mov al, 0x20
out dx, al
```

第四步，等待读写操作完成。端口`0x1f7`即是命令端口，又是状态端口。在通过这个端口发送读写命令后，硬盘就处于busy。在它内部操作期间，它将`0x1f7`端口的第7位置1，表明busy。一旦硬盘系统准备就绪，它再将此位清零，同时将第3位置为1。

```asm
  mov dx, 0x1f7
.waits:
  in al, dx
  and al, 0x88
  cmp al, 0x08
  jnz .waits
```

第五步，连续从`0x1f0`取出数据，注意一次读取的数据大小为16位。

```asm
  mov cx, 256
  mov dx, 0x1f0
.readw:
  in ax, dx
  mov [bx], ax
  add bx, 2
  loop .readw
```
