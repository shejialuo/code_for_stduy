# Chapter 5 编写主引导扇区代码

## 欢迎来到主引导扇区

读取的主引导扇区有512字节，ROM-BIOS程序将它加载到逻辑地址`0x0000:0x7c00`处，然后判断它是否有效。

一个有效的主引导扇区，其最后两字节应当是`0x55`和`0xAA`。ROM-BIOS程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令`jmp 0x0000:0x7c00`跳到那里继续执行。

## 在屏幕上显示文字

为了显示一段文字，通常需要两种硬件，一是显示器，二是显卡。显卡有自己的存储器，称为显存。

对显示器来说，显示黑白图像是最简单的，因为只需要控制每个像素是亮，还是不亮。将不亮作为0，亮作为1。显卡的工作是周期性地从显存中提取出这些比特，并把它们按顺序显示在屏幕上。

然而亮与不亮只是最简单的显示，因此如何使得显存里的比特能够让屏幕显示字符的形状。故采取了ASCII码来处理。

如下图所示，可以将字符的代码存放到显存里，第1个代码对应着屏幕左上角第1一个字符，第2个代码对应这屏幕左上角第2个字符。传统上，这种专门用于显示字符的工作方式称为文本模式。文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。

[符在屏幕上的显示原理](https://s2.loli.net/2022/03/13/zAv2WwLqK7mCFHo.png)

为了提高速度，将显存映射到处理器可以直接访问的地址空间也就是内存空间。由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化到$80 \times 25$的文本模式。在这种模式下，屏幕可以显示25行，每行80个字符。故显卡的地址空间为`0xB8000~0xBFFFF`。

### 初始化段寄存器

和访问主内存一样，为了访问显存，也需要使用逻辑地址。访问内存可以使用段寄存器DS，也可以使用ES。

源程序第6、7行，首先把立即数`0xB800`传送到`AX`，然后再把`AX`的值传送到`ES`。 Intel的处理器不允许将一个立即数传送到段寄存器，故需要两个指令进行处理。

### 显示字符

从源程序的第10行开始，到第35行将字符按照顺序写到显存中。为了方便，多数汇编语言编译器允许在指令中直接使用字符的字面值来代替数值形式的ASCII码：

```asm
mov byte [es:0x00], 'L'
```

为了访问内存单元，需要给出段地址和偏移地址。一般情况下，如果没有附加任何指示，段地址默认在段寄存器DS中，例如：

```asm
mov byte [0x00], 'L'
```

## 显示标号的汇编地址

### 标号

处理器访问内存时，采用的是`segment:offset`的模式。对于任何一个内存段来说，段地址可以开始于任何16字节对齐的地方，偏移地址总是从`0x0000`开始递增。

为了支持这种内存访问模式，在源程序的编译阶段，编译器会把源程序整体上作为一个独立的段来处理，并从0开始计算和跟踪每一条指令的地址。因为该地址是在编译期间计算的，故称为汇编地址。

在编译阶段，每条指令都被计算并赋予了一个汇编地址，故可以采用标号进行跳转。  

### 如何显示十进制数字

简单的算法处理。

### 在程序中声明并初始化数据

要放在程序中的数据是用`DB`指令来声明的，`DB`的意思是声明字节，所以，跟在它后面的操作数都占一个字节的长度。`DW`用于声明字数据，`DD`用于声明双字数据，`DQ`用于声明四字数据。上述指令并不是处理器指令，只是编译器提供的汇编指令，称为伪指令。

按照标准的做法，在程序中用到的数据应当声明在一个独立的段，即数据段中。本书采用的是数据和指令放在同一个段中。

### 分解数的各个位数

8086提供了除法指令`div`:

+ 用16位的二进制数除以8位的二进制数。在这种情况下，被除数必须在寄存器`AX`中。指令执行后，商在寄存器`AL`中，余数在寄存器`AH`中。
+ 用32位的二进制数除以16位的二进制数。要求被除数的高16位在`DX`中，低16位在`AX`中。

## 使程序进入无限循环状态

```asm
infi: jmp near infi
```

`jmp`指令有多种格式：

+ `jmp <segment:offset>`
+ `jmp near inif`

对于`jmp near inif`，很容易地认为指令中的操作数是`inif`的偏移地址。这是一种错误的认识。在编译阶段，编译器用目标位置处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度3，得到实际操作数。在指令执行阶段，处理器用指令指针寄存器IP的内容加上该指令的操作数，再加上指令的长度，就得到了要转移的实际偏移地址。
