# Chapter 7 比高斯更快的计算

## 累加和各个数位的分解与显示

### 栈和栈段的初始化

定义栈需要两个连续的步骤，即初始化段寄存器`SS`和栈指针`SP`的内容。

### 进一步认识栈

+ `push`指令的操作数可以是16位寄存器或者16位内存单元，`push`指令执行后，压入栈中的仅仅是该寄存器或者内存单元的数值，与该寄存器或内存单元不再相干。
+ 栈在本质上也只是普通的内存区域。
+ 保持栈平衡。
+ 防止栈溢出。

## 8086处理器的寻址方式

### 寄存器寻址

最简单的寻址方式是寄存器寻址。执行指令时，操作的数位于寄存器中，可以从寄存器里取得。

```asm
mov ax, cx
add bx, 0xf000
inc dx
```

### 立即寻址

立即寻址又叫立即数寻址。指令的操作数是一个立即数。

```asm
add bx, 0xf000
mov dx, label_a
```

### 内存寻址

#### 直接寻址

```asm
mov ax, [0x5c0f]
xor byte [es:label_b], 0x05
```

很多时候，我们会有一大堆的数据需要处理，而且它们通常位于连续的内存中：

```asm
buffer dw 0x20, 0x100, 0x0f, 0x300, 0xff00
```

使用直接寻址的方式处理：

```asm
inc word [buffer]
inc word [buffer+2]
inc word [buff+4]
```

这样的代码应该使用基址寻址：

```asm
mov bx, buffer
mov cx, 4
lpinc:
  inc word [bx]
  add bx, 2
  loop lpinc
```

基址寻址的寄存器也可以是`BP`，其默认的段寄存器是`SS`。

```asm
mov ax, 0x5000
push ax
mov ax, 0x7000
push ax
```

如果要用pop指令弹出数据，就必须弹出`0x7000`，才能弹出`0x5000`。但是有时候我们希望可以越过这种限制，去访问栈中的内容，还不能破坏栈的形态。一个典型的例子为高级语言中函数的调用，所有的参数都位于栈中。为了能访问那些被压在栈底的参数：

```asm
mov ax, 0x5000
push ax
mov bp, sp
mov ax, 0x7000
push ax
mov dx, [dp]
```

#### 变址寻址

变址寻址类似于基址寻址。
